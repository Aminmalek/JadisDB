**01 فایل ها در مقایسه با دیتابیس ها**

 این فصل محدودیت‌های ذخیره ساده داده‌ها در فایل‌ها و مشکلاتی که پایگاه‌های داده حل می‌کنند را نشان می‌دهد. 

 **1.1 ذخیره داده‌ها در فایل‌ها**
 
 
  فرض کنید داده‌هایی دارید که 
 نیاز به ذخیره شدن در یک فایل دارند؛ این یک روش معمول برای  ذخبره است:

```go

   func SaveData1(path string, data []byte) error {
    fp, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)
    if err != nil {
        return err
    }
    defer fp.Close()
    _, err = fp.Write(data)
    return err
    }
    
```

این روش ساده دارای معایبی است:

فایل را قبل از به‌روزرسانی پاک می‌کند. 
اگر فایل نیاز به خواندن همزمان داشته باشد چه می‌شود؟

نوشتن داده‌ها در فایل ممکن است اتمیک نباشد، وابسته به اندازه داده خوانندگان همزمان ممکن است داده ناقص دریافت کنند.

چه زمانی داده واقعاً روی دیسک ذخیره می‌شود؟
 بعد از بازگشت از فراخوانی write، داده احتمالاً هنوز در حافظه کش سیستم‌عامل است.
 اگر سیستم خراب شود، وضعیت فایل چگونه خواهد بود؟

 **1.2 تغییر نام اتمیک**
 برای حل برخی از این مشکلات، بیایید یک روش بهتر پیشنهاد دهیم:

```go

    func SaveData2(path string, data []byte) error {
    tmp := fmt.Sprintf("%s.tmp.%d", path, randomInt())
    fp, err := os.OpenFile(tmp, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0664)
    if err != nil {
        return err
    }
    defer fp.Close()
    _, err = fp.Write(data)
    if err != nil {
        os.Remove(tmp)
        return err
    }
    return os.Rename(tmp, path)
    }

```

این روش ابتدا داده‌ها را در یک فایل موقت ذخیره کرده و سپس آن را به فایل هدف تغییر نام می‌دهد. این روش به نظر می‌رسد که مشکل غیراتمیک بودن را حل می‌کند، زیرا عمل rename اتمیک است. اگر سیستم قبل از تغییر نام خراب شود، فایل اصلی دست نخورده باقی می‌ماند.



 **1.3 استفاده از fsync**

برای رفع کامل مشکل، داده‌ها باید قبل از تغییر نام، به دیسک فلاش شوند. فراخوانی سیستمی fsync در لینوکس برای این منظور استفاده می‌شود:

```go

    func SaveData3(path string, data []byte) error {
    //code omitted...
    _, err := fp.Write(data)
    if err != nil {
        os.Remove(tmp)
        return err
    }
    err = fp.Sync() // fsync
    if err != nil {
        os.Remove(tmp)
        return err
    }
    return os.Rename(tmp, path)
    }

```

آیا کار تمام شده است؟ پاسخ خیر است. ما داده‌ها را به دیسک منتقل flushed کرده‌ایم، اما در مورد متادیتا چطور؟ آیا باید fsync را روی دایرکتوری حاوی فایل هم فراخوانی کنیم؟ این مسئله بسیار پیچیده است و به همین دلیل پایگاه‌های داده برای ذخیره داده‌ها ترجیح داده می‌شوند.

 **1.4 استفاده از fsync**

 در برخی موارد منطقی است که داده‌ها را با استفاده از یک لاگ فقط افزودنی ذخیره کنیم:

```go

    func LogCreate(path string) (*os.File, error) {
    return os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0664)
    }

    func LogAppend(fp *os.File, line string) error {
    buf := []byte(line)
    buf = append(buf, '\n')
    _, err := fp.Write(buf)
    if err != nil {
        return err
    }
    return fp.Sync() // fsync
    }

```

ویژگی مثبت این لاگ این است که داده‌های موجود را تغییر نمی‌دهد و نیازی به عملیات rename ندارد، که آن را در برابر خرابی مقاوم‌تر می‌کند. اما لاگ‌ها به تنهایی برای ساخت یک پایگاه داده کافی نیستند.

1- یک پایگاه داده از اندیس‌ها برای جستجوی کارآمد داده‌ها استفاده می‌کند. در غیر این صورت، تنها روش موجود برای جستجوی مجموعه‌ای از رکوردها، جستجوی خطی (brute-force) خواهد بود.

2- 
لاگ‌ها چگونه داده‌های حذف شده را مدیریت می‌کنند؟ آن‌ها نمی‌توانند برای همیشه رشد کنند.


ما برخی از مشکلاتی که باید حل شوند را بررسی کردیم. در فصل بعدی با موضوع ایندکسینگ شروع خواهیم کرد.