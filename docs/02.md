**02. ایندکس‌گذاری**

2.1 ذخیره‌سازی key-value و پایگاه داده رابطه‌ای
اگرچه یک پایگاه داده رابطه‌ای از انواع متعددی از کوئری‌ها پشتیبانی می‌کند، تقریباً تمام کوئری‌ها را می‌توان به سه نوع
عملیات دیسک تقسیم کرد:

* اسکن کل مجموعه داده‌ها (بدون استفاده از ایندکس).
*  کوئری نقطه‌ای: کوئری از طریق یک کلید خاص در ایندکس.
* کوئری بازه‌ای(range query): کوئری ایندکس بر اساس یک بازه (ایندکس به صورت مرتب شده است).
* ایندکس‌های پایگاه داده عمدتاً برای کوئری‌های بازه‌ای و نقطه‌ای طراحی شده‌اند و واضح است که یک کوئری بازه‌ای، یک مجموعه
  بزرگ‌تر از کوئری نقطه‌ای است. اگر عملکرد ایندکس‌های پایگاه داده را استخراج کنیم، ساخت یک ذخیره‌سازی کلید-مقدار بسیار
  ساده می‌شود. اما نکته اینجاست که یک سیستم پایگاه داده می‌تواند بر اساس یک ذخیره‌سازی key-value ساخته شود.

ما ابتدا یک پایگاه داده key-value ایجاد می‌کنیم و
سپس سراغ ساخت پایگاه داده رابطه‌ای می‌رویم. اما ابتدا باید گزینه‌های خود را بررسی کنیم.

**2.2 Hashtables**

هش تیبل ها اولین گزینه‌ای هستند که هنگام طراحی یک پایگاه داده key-value
عمومی کنار گذاشته می‌شوند. دلیل اصلی این موضوع مرتب‌سازی است —
بسیاری از کاربردهای دنیای واقعی به مرتب‌سازی و sorting نیاز دارند.
با این حال، استفاده از جدول‌های هش در کاربردهای خاص ممکن است امکان‌پذیر باشد. یک مشکل دیگر در استفاده از جدول‌های هش،
عملیات تغییر اندازه (resizing) است. تغییر اندازه ساده (O(n) است و باعث افزایش ناگهانی مصرف فضای دیسک و عملیات IO می‌شود.
البته می‌توان تغییر اندازه را
به صورت تدریجی انجام داد، اما این کار پیچیدگی را افزایش می‌دهد.

**2.3 درخت‌های B**

درخت‌های باینری بالانس را می‌توان در زمان O(log(n) کوئری
و به‌روزرسانی کرد و همچنین برای کوئری‌های بازه‌ای مناسب هستند.
درخت‌های B به صورت تقریبی نوعی درخت متعادل n-ary (n تایی) هستند
. چرا از درخت n-ary به جای باینری استفاده کنیم؟

دلایل زیادی وجود دارد:

* مصرف فضای کمتر:


* هر گره برگ در یک درخت دودویی از طریق اشاره‌گر از گره والد خود
* دسترسی‌پذیر است و ممکن است والد نیز خودش یک والد داشته باشد.
* به طور میانگین، هر گره برگ نیاز به ۱ تا ۲ اشاره‌گر دارد.
  در مقابل، در درخت‌های B، چندین داده در یک
* گره برگ توسط یک والد به اشتراک گذاشته می‌شود. درخت‌های n-ary همچنین
* ارتفاع کمتری دارند، بنابراین فضای کمتری برای اشاره‌گرها هدر می‌رود.
  سرعت بیشتر در حافظه:


* به دلیل کش حافظه CPU و سایر عوامل مدرن، درخت‌های n-ary حتی با
* وجود پیچیدگی Big-O مشابه، می‌توانند سریع‌تر از درخت‌های دودویی باشند.
* 
**کاهش IO دیسک:**

درخت‌های B کوتاه‌تر هستند، بنابراین به جستجوهای دیسک کمتری نیاز دارند.

حداقل اندازه عملیات ورودی/خروجی دیسک معمولاً برابر با اندازه یک صفحه حافظه (احتمالاً ۴K) است. سیستم‌عامل کل صفحه ۴K را
پر می‌کند، حتی اگر اندازه داده‌های خوانده‌شده کمتر باشد. اگر اندازه گره‌ها حداقل به اندازه یک صفحه تنظیم شود، استفاده
بهینه‌ای از اطلاعات صفحه صورت می‌گیرد.

ما از درخت‌های B در این کتاب استفاده خواهیم کرد. اما **درخت‌های B** تنها گزینه موجود نیستند.

**2.4 درخت‌های LSM**

درخت‌های Log-structured Merge-tree. در اینجا یک نمای کلی از عملیات LSM-Tree آورده شده است:

نحوه کوئری:

یک درخت LSM شامل چندین سطح داده است.
هر سطح مرتب شده و به چند فایل تقسیم می‌شود.
یک کوئری نقطه‌ای(point query) از سطح بالا شروع می‌شود. اگر کلید پیدا نشود، جستجو به سطح بعدی ادامه می‌یابد.
یک کوئری بازه‌ای نتایج تمام سطوح را ترکیب می‌کند، سطح‌های بالاتر اولویت بیشتری در ترکیب دارند.
نحوه به‌روزرسانی:

5. هنگام به‌روزرسانی یک کلید، ابتدا کلید به یک فایل در سطح بالا اضافه می‌شود.
6. اگر اندازه فایل از یک آستانه مشخص عبور کند، با سطح بعدی ادغام می‌شود.
7. آستانه اندازه فایل به صورت نمایی با هر سطح افزایش می‌یابد، به این معنا که داده‌ها نیز به صورت نمایی افزایش می‌یابند.

تحلیل عملکرد:

برای کوئری‌ها:

هر سطح مرتب است، کلیدها می‌توانند از طریق جستجوی دودویی یافت شوند و کوئری‌های بازه‌ای به صورت IO ترتیبی انجام می‌شوند.
این روش کارآمد است.
برای به‌روزرسانی‌ها:

2. اندازه فایل سطح بالا کوچک است، بنابراین وارد کردن داده به سطح بالا تنها به مقدار کمی IO نیاز دارد.
3. داده‌ها در نهایت با سطوح پایین‌تر ادغام می‌شوند. ادغام به صورت IO ترتیبی است که یک مزیت محسوب می‌شود.
4. سطوح بالاتر بیشتر ادغام می‌شوند، اما اندازه ادغام نیز کوچکتر است.
5. هنگام ادغام یک فایل به سطح پایین‌تر، فایل‌های پایین‌تری که بازه‌های آن‌ها همپوشانی دارند با نتایج ادغام‌شده جایگزین
   می‌شوند (که می‌توانند شامل چندین فایل باشند). به همین دلیل است که سطوح به چندین فایل تقسیم می‌شوند — برای کاهش اندازه
   ادغام.
6. ادغام می‌تواند در پس‌زمینه انجام شود. اما ادغام در سطوح پایین ممکن است به طور ناگهانی باعث استفاده زیاد از IO شود که
   می‌تواند عملکرد سیستم را کاهش دهد.

پیشنهاد: خوانندگان می‌توانند پس از پایان این کتاب از درخت‌های LSM به جای درخت‌های B استفاده کنند و مزایا و معایب آن‌ها
را مقایسه کنند.